GIT REPOSITORY
https://github.com/kubicek-skoleni/aspnet/

dot.net
https://dotnet.microsoft.com/en-us/apps/aspnet
https://learn.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-7.0

Bootstrap.com
https://getbootstrap.com/
https://bootswatch.com/

alternativy
https://picocss.com/

https://materializecss.com/

https://tailwindcss.com/

https://themeforest.net/


VS
- (ctrl + Q) prohledává okna/funkce


IActionResult / interface (rùzné návratové typy, které splnují urèité podmínky - polymorfismus)

V home controller jsem pridal metodu Hello. Tu zavolám pomocí URL:
https://localhost:7274/Home/Hello


Pokud metoda xxx vrací View(), pøesmìruje se vıstup na xxx.cshtml ve views

Komentáøe: zaèátek - @* konec - *@

Metoda @RenderBody() v _Loyout odkazuje na konkrétní pouité stránky

TAG HELPERS
https://learn.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-7.0

asp-append-version="true" - pouití pro cachování lokální / jednou naète a poté jen lokální naèítá.
						- pøi zmìnì obsahu souboru se zmìní URL a pak naète novı soubor

Routing
 - kam aplikace nasmìruje
 -defaultni nastavení:
        app.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");

Models:
 místo List<> pouívat radìji  ICollection - kvùli Entity Framework
     public ICollection<Contract> Contracts { get; set; } = new HashSet<Contract>();
Podstrèení vlastního pojmenování prvkù pomocí atributu [Display(Name = "Jméno")]]
    [MaxLength(250)]
    [Display(Name = "Jméno")]
    public string? FirstName { get; set; }
Urèení zobrazení jen data pro DateTime:
    [DataType(DataType.Date)]

Data

public virtual DbSet<Address> Addresses { get; set; } kde Addresses je název tabulky v DB

Controler
1)  Dependenci Injection - podstrèit dbContext do konstruktoru
        private readonly InsCorpDbContext _context;
        public PersonController(InsCorpDbContext context)
        {
            _context = context;
        }
2)  Naplnìní dat pomocí LINQ a pøedání do View

Propojení s MVC

do program.cs pøidat DbContext pøed 'var app = builder.Build();':
    builder.Services.AddDbContext<InsCorpDbContext>();

pøedání hodnot do view:
    pøes dictionary ViewData: ViewData["status"] = status;


using pro všechny view:
vloení do _ViewImports.cshtml

pøístup k datùm z propojené tabulky - .Include()
var top100 = _context.Persons.Include(person => person.Constracts)
                .OrderBy(person => person.Id)
                .Take(100).ToList();

Formuláø:

1)  formuláø jako takovı
2) metoda, která zpracuje data z formuláøe

deklarace 2. metody pomocí atributu [HttpPost] + model binding
        public IActionResult Add()
        {
            return View();
        }

        [HttpPost]
        public IActionResult Add(Person person)
        {
            // ulozit osobu do DB
            _context.Persons.Add(person);
            _context.SaveChanges();

            // navrat GUI
            return Redirect($"/person/detail/{person.Id}");
        }

Ošetøení špatného requestu:

1)  return NotFound(); - metoda se dìdí od Controller
            // ziskat data
            var person = _context.Persons.Find(id);

            if(person == null)
            {
                return NotFound();
            }

Edit:
 1] aktualiyace prvku po prvku
    dbPerson.FirstName  = formPerson.FirstName; ...
 2] pøiøazení novıch hodnot z Form objektu z DB: - pokud mám ve formuláøi všechny vlastnosti!
    _context.Entry(dbPerson).CurrentValues.SetValues(formPerson);
 3] objektu z form pøiøadit status MODIFIED
    _context.Entry(dbPerson).State = EntityState.Modified;

    doporuèuje se nezasahovat do vnitrnich stavu - u jednoducheho zvolit 1) a delších 2)


pøihlášení uivatelù:
[Authorize] atribut u metod

Databáze:

create: update-database -Context ApplicationDbContext
migrace: add-migration BirthNumber -Context InsCorpDbContext
        update-database -Context InsCorpDbContext

Database First:
    EF Core Power Tools
    https://marketplace.visualstudio.com/items?itemName=ErikEJ.EFCorePowerTools
        


 === A P I ===

 Application interface - vracení dat v JSON pro klienta místo vyrenderovanıch stránek jako v MVC

 [Route("api/[controller]")] - [controller] vezme název kontroleru

 [Route("city/{city}")]
 [HttpGet]

 // dohromady lze zapsat jako:
 [HttpGet("city/{city}")]

 vıbìr jen nìkterıch prvkù z tabulky
    - vytvoøit vlastní tøídu pro návratovı typ Task<ActionResult<IEnumerable<TypProNavrat>>>
    - nebo dotaz zabalit do funkce Ok(), ale návrtovı typ zmìnit na Task<ActionResult>
        return Ok(_context.Persons
                        .Include(person => person.Address)
                        .Where(person => person.Address!=null && person.Address.City.ToUpper() == city.ToUpper())
                        .Select(person => new { person.FirstName, person.LastName, person.Address.City })
                        .ToList());

    - poté pouít .Select(person => new {person.FirstName, person.LastName, person.Address.City})

    Middleware:
    vlastní pro logování requestu:
        - vytvoøit sloku Middleware
        - vytvoøit pøedpripravenou tøídu Middleware
        - injectnout metodu Invoke

            public Task Invoke(HttpContext httpContext, InsCorpDbContext context)
        {
            // ziskat informace o requestu a odeslat do DB
            var url = httpContext.Request.Path;
            var ip = httpContext.Connection.RemoteIpAddress.MapToIPv4().ToString();

            // ulozeni do databaze
            context.LogRequests.Add(new Model.RequestLog()
            {
                Date = DateTime.Now,
                Url= url,
                IP= ip
            });

            context.SaveChanges();


            return _next(httpContext);
        }
    
    - do Program.cs voit Use Middleware
        app.UseLogRequestMiddleware();

Minimal API
- vše jen v Program.cs, bez kontroleru
    app.MapGet()




=== B L A Z O R ===
https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor
https://blazor-university.com/

Single Page Aplications (SPA)
SPA framework aplikace = stáhne si vše(na pozadí naèítání dalších dat dle potøeby), dále se chová podle javascript eventù v prohlíeèi

FW - javascript v prohlíeèi, postaveno na Ajax

Klienta ale programujeme v C# ! nemusíme pøijít do styku s JavaScriptem

if (!app.Environment.IsDevelopment()) - zjišování, jestli je program pouštìn z VS

@page "/counter" - kam z URL pujde

<p role="status">Current count: @currentCount</p> - lokální promìnná definovaná v @code, je naBindovaná a dynamické aktualizace
<button class="btn btn-primary" @onclick="IncrementCount">Click me</button> - volání lokální metody, kde dochází k aktualizaci lokální promìnné a dynamicky se upraví hodnota v html

není konstruktor, proto se Injectuje na zaèátku .razer :
        @inject WeatherForecastService ForecastService

        @page "/person/detail/{Id:int}" - promena v URL
        v @code se definuje jako:

        <InputDate @bind-Value="person.DateOfBirth" /> - nabindovani property
            

